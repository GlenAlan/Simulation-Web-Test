<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Convection Simulation</title>
  <style>
    body { 
      margin: 0; 
      padding: 0;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
      background: #222; 
      color: #fff; 
      font-family: sans-serif;
    }
    
    .container {
      position: relative;
      width: 90%;
      max-width: 600px;
      margin: 20px auto;
      display: flex;
      flex-direction: column;
      align-items: center;
      overflow: visible;
    }
    
    .canvas-wrapper {
      width: 100%;
      padding-bottom: 100%; /* 1:1 Aspect Ratio */
      position: relative;
      overflow: hidden;
      border-radius: 8px;
      box-shadow: 0 5px 15px rgba(0,0,0,0.3);
    }
    
    canvas { 
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: #000;
      touch-action: none;
      image-rendering: -webkit-optimize-contrast;
      image-rendering: crisp-edges;
    }
    
    #controls {
      width: 100%;
      background: rgba(0, 0, 0, 0.30);
      padding: 12px;
      border-radius: 8px;
      box-sizing: border-box;
      margin-top: 15px;
      box-shadow: 0 5px 15px rgba(0,0,0,0.3);
    }
    
    #controls-content {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
    }
    
    #controls label { 
      display: block;
      flex: 1 1 calc(50% - 10px);
      min-width: 120px;
      margin: 0;
      font-size: 14px;
    }
    
    #controls input { 
      width: 100%;
    }
    
    #fps {
      position: absolute;
      top: 10px;
      right: 10px;
      background: rgba(0,0,0,0.5);
      padding: 5px;
      border-radius: 3px;
      font-size: 12px;
      color: #fff;
      display: none;
    }
    
    /* Hamburger Menu */
    .hamburger {
      display: none;
      position: absolute;
      top: 10px;
      left: 10px;
      z-index: 2;
      background: rgba(0,0,0,0.7);
      border-radius: 5px;
      padding: 10px;
      cursor: pointer;
      box-shadow: 0 2px 5px rgba(0,0,0,0.3);
    }
    
    .hamburger div {
      width: 25px;
      height: 3px;
      background-color: white;
      margin: 5px 0;
      border-radius: 2px;
    }
    
    @media (max-width: 600px) {
      .container {
        width: 95%;
      }
      
      .hamburger {
        display: block;
      }
      
      #controls {
        position: absolute;
        top: 10px;
        left: -100%;
        width: 80%;
        max-width: 250px;
        transition: left 0.3s ease;
        z-index: 3;
      }
      
      #controls.visible {
        left: 0;
      }
      
      #controls-content {
        flex-direction: column;
      }
      
      #controls label {
        flex: 1 1 100%;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="hamburger" id="menu-toggle">
      <div></div>
      <div></div>
      <div></div>
    </div>
    <div class="canvas-wrapper">
      <canvas id="canvas"></canvas>
      <div id="fps">FPS: 0</div>
    </div>
    <div id="controls">
      <div id="controls-content">
        <label>Simulation Speed: <span id="timeScaleVal">1.0</span>x
          <input type="range" id="timeScale" min="0.1" max="10" step="0.1" value="1.0">
        </label>
        <label>Heating Radius: <span id="heatSizeVal">5</span>
          <input type="range" id="heatSize" min="1" max="20" step="1" value="5">
        </label>
        <label>Heat Intensity: <span id="heatAmpVal">0.50</span>
          <input type="range" id="heatAmp" min="0.01" max="1" step="0.01" value="0.50">
        </label>
        <label>Surface Cooling: <span id="coolRateVal">0.5</span>
          <input type="range" id="coolRate" min="0" max="1" step="0.01" value="0.50">
        </label>
      </div>
    </div>
  </div>
  <script>
    // GRID & PHYSICS PARAMETERS
    const N    = 64,            // interior cells per side
          size = N + 2,         // include ghost cells
          iter = 4;             // Gaussâ€“Seidel iterations
    const diff   = 0.0001,      // thermal diffusion
          visc   = 0.0001,      // kinematic viscosity
          buoyancyCoeff = 1.0,  // strength of buoyant force
          ambientTemp   = 0.5;  // reference temperature
    
    // TIME MANAGEMENT
    const physicsDt = 0.02;     // physics timestep (now fixed and separated from rendering)
    const targetPhysicsRate = 60; // target physics updates per second
    let accumulatedTime = 0;    // time accumulated since last frame
    let timeScale = 1.0;        // user-controllable time scale
    let lastTimestamp = 0;      // last frame timestamp
    
    // FPS TRACKING
    let frameCount = 0;
    let lastFpsUpdate = 0;
    let currentFps = 0;
    
    // FLUID STATE ARRAYS
    let u        = new Float32Array(size*size),
        v        = new Float32Array(size*size),
        u_prev   = new Float32Array(size*size),
        v_prev   = new Float32Array(size*size),
        dens     = new Float32Array(size*size),
        dens_prev= new Float32Array(size*size);

    // scratch arrays for solver
    const u0    = new Float32Array(size*size),
          v0    = new Float32Array(size*size),
          dens0 = new Float32Array(size*size);

    // initialize all cells to ambient temperature
    for (let i = 0; i < dens.length; i++) dens[i] = ambientTemp;

    let avg_density = ambientTemp; // average density for buoyancy
    let prev_avg_density = ambientTemp; // previous average density for buoyancy

    // UI STATE
    let heatRadius = 5,
        heatAmp    = 0.5,
        coolRate   = 0.5,
        heating    = false,
        mX = 0, mY = 0;

    // DOM REFS
    const canvas      = document.getElementById('canvas'),
          ctx         = canvas.getContext('2d'),
          timeSlider  = document.getElementById('timeScale'),
          timeVal     = document.getElementById('timeScaleVal'),
          radiusSlider= document.getElementById('heatSize'),
          radiusVal   = document.getElementById('heatSizeVal'),
          ampSlider   = document.getElementById('heatAmp'),
          ampVal      = document.getElementById('heatAmpVal'),
          coolSlider  = document.getElementById('coolRate'),
          coolVal     = document.getElementById('coolRateVal'),
          fpsDisplay  = document.getElementById('fps');

    // Resize canvas to match wrapper dimensions
    function resizeCanvas() {
      const wrapper = canvas.parentElement;
      const rect = wrapper.getBoundingClientRect();
      
      // Set the canvas dimensions to match the wrapper's actual size
      canvas.width = rect.width;
      canvas.height = rect.height;
    }

    // Adjust simulation to fit properly on screen
    function adjustSimulationSize() {
      const container = document.querySelector('.container');
      const canvasWrapper = document.querySelector('.canvas-wrapper');
      const controlsHeight = document.getElementById('controls').offsetHeight;
      const viewportHeight = window.innerHeight;
      const viewportWidth = window.innerWidth;
      
      // Calculate available height (account for margins)
      const availableHeight = viewportHeight - 40; // 20px top and bottom margin
      
      if (window.innerWidth <= 600) {
        // Mobile: center the canvas on screen
        const maxDimension = Math.min(viewportWidth * 0.95, availableHeight * 0.8);
        canvasWrapper.style.width = maxDimension + 'px';
        canvasWrapper.style.paddingBottom = maxDimension + 'px';
        container.style.margin = '20px auto';
      } else {
        // Desktop: ensure simulation + controls fit on screen
        const maxCanvasHeight = availableHeight - controlsHeight - 20; // 20px for margins
        const maxWidth = Math.min(viewportWidth * 0.9, 600); // Use 90% of viewport width, max 600px
        const maxCanvasWidth = maxWidth;
        
        // Use the smaller of width or height to ensure it fits
        const maxDimension = Math.min(maxCanvasWidth, maxCanvasHeight);
        
        canvasWrapper.style.width = maxDimension + 'px';
        canvasWrapper.style.paddingBottom = maxDimension + 'px';
        
        // Center the container
        container.style.margin = '20px auto';
      }
      
      // Resize canvas to match wrapper
      resizeCanvas();
    }
    
    // Ensure canvas resizes when window size changes
    window.addEventListener('load', () => {
      adjustSimulationSize();
      // Trigger resize again after a short delay to account for any DOM rendering delays
      setTimeout(adjustSimulationSize, 100);
    });
    
    window.addEventListener('resize', () => {
      adjustSimulationSize();
    });

    // SLIDER HANDLERS
    timeSlider.oninput   = () => { timeScale = +timeSlider.value; timeVal.textContent = timeScale.toFixed(1); };
    radiusSlider.oninput = () => { heatRadius = +radiusSlider.value; radiusVal.textContent = heatRadius; };
    ampSlider.oninput    = () => { heatAmp = +ampSlider.value; ampVal.textContent = heatAmp.toFixed(2); };
    coolSlider.oninput   = () => { coolRate = +coolSlider.value; coolVal.textContent = coolRate.toFixed(2); };

    // Touch and mouse position handler
    function updatePosition(e) {
      const r = canvas.getBoundingClientRect();
      let clientX, clientY;
      
      // Handle both touch and mouse events
      if (e.touches) { // Touch event
        clientX = e.touches[0].clientX;
        clientY = e.touches[0].clientY;
      } else { // Mouse event
        clientX = e.clientX;
        clientY = e.clientY;
      }
      
      mX = clientX - r.left;
      mY = clientY - r.top;
      
      // Scale to canvas coordinates if the canvas is resized
      mX = mX * (canvas.width / r.width);
      mY = mY * (canvas.height / r.height);
    }

    // MOUSE EVENTS
    canvas.addEventListener('mousedown', () => heating = true);
    canvas.addEventListener('mouseup', () => heating = false);
    canvas.addEventListener('mouseleave', () => heating = false);
    canvas.addEventListener('mousemove', updatePosition);

    // TOUCH EVENTS
    canvas.addEventListener('touchstart', (e) => {
      e.preventDefault(); // Prevent default touch behavior
      heating = true;
      updatePosition(e);
    });
    canvas.addEventListener('touchend', () => heating = false);
    canvas.addEventListener('touchcancel', () => heating = false);
    canvas.addEventListener('touchmove', (e) => {
      e.preventDefault(); // Prevent scrolling
      updatePosition(e);
    });
    
    // Hamburger menu toggle
    const menuToggle = document.getElementById('menu-toggle');
    const controlsPanel = document.getElementById('controls');
    
    menuToggle.addEventListener('click', () => {
      controlsPanel.classList.toggle('visible');
    });
    
    // Close menu when clicking outside
    document.addEventListener('click', (e) => {
      if (window.innerWidth <= 600) {
        if (!controlsPanel.contains(e.target) && !menuToggle.contains(e.target)) {
          controlsPanel.classList.remove('visible');
        }
      }
    });

    // INDEX UTILITY: (i,j) â†’ 1D
    function IX(i,j){ return i + j*size; }

    // NO-FLUX BOUNDARIES
    function setBnd(b, x) {
      for (let i = 1; i <= N; i++) {
        x[IX(0,   i)] = b===1 ? -x[IX(1, i)] : x[IX(1, i)];
        x[IX(N+1, i)] = b===1 ? -x[IX(N, i)] : x[IX(N, i)];
        x[IX(i,   0)] = b===2 ? -x[IX(i, 1)] : x[IX(i, 1)];
        x[IX(i, N+1)] = b===2 ? -x[IX(i, N)] : x[IX(i, N)];
      }
      // corners
      x[IX(0,   0)]     = 0.5*(x[IX(1,0)]   + x[IX(0,1)]);
      x[IX(0,   N+1)]   = 0.5*(x[IX(1,N+1)]+ x[IX(0,N)]);
      x[IX(N+1, 0)]     = 0.5*(x[IX(N,0)]   + x[IX(N+1,1)]);
      x[IX(N+1, N+1)]   = 0.5*(x[IX(N, N+1)]+ x[IX(N+1,N)]);
    }

    // GAUSSâ€“SEIDEL SOLVER
    function linSolve(b, x, x0, a, c) {
      for (let k = 0; k < iter; k++) {
        for (let j = 1; j <= N; j++) {
          for (let i = 1; i <= N; i++) {
            x[IX(i,j)] = (x0[IX(i,j)] + a*(
              x[IX(i-1,j)] + x[IX(i+1,j)] +
              x[IX(i, j-1)] + x[IX(i, j+1)]
            ))/c;
          }
        }
        setBnd(b, x);
      }
    }

    // DIFFUSION
    function diffuse(b, x, x0, diff) {
      const a = physicsDt * diff * N * N;
      linSolve(b, x, x0, a, 1 + 4*a);
    }

    // ADVECTION
    function advect(b, d, d0, u, v) {
      const dt0 = physicsDt * N;
      for (let j = 1; j <= N; j++) {
        for (let i = 1; i <= N; i++) {
          let x = i - dt0 * u[IX(i,j)];
          let y = j - dt0 * v[IX(i,j)];
          x = Math.max(0.5, Math.min(N + 0.5, x));
          y = Math.max(0.5, Math.min(N + 0.5, y));
          const i0 = Math.floor(x), i1 = i0 + 1;
          const j0 = Math.floor(y), j1 = j0 + 1;
          const s1 = x - i0, s0 = 1 - s1;
          const t1 = y - j0, t0 = 1 - t1;
          d[IX(i,j)] =
            s0*(t0*d0[IX(i0,j0)] + t1*d0[IX(i0,j1)]) +
            s1*(t0*d0[IX(i1,j0)] + t1*d0[IX(i1,j1)]);
        }
      }
      setBnd(b, d);
    }

    // MAKE VELOCITY DIV-FREE
    function project(u, v, p, div) {
      for (let j = 1; j <= N; j++) {
        for (let i = 1; i <= N; i++) {
          div[IX(i,j)] = -0.5*(
            u[IX(i+1,j)] - u[IX(i-1,j)] +
            v[IX(i, j+1)] - v[IX(i, j-1)]
          )/N;
          p[IX(i,j)] = 0;
        }
      }
      setBnd(0, div);
      setBnd(0, p);
      linSolve(0, p, div, 1, 4);
      for (let j = 1; j <= N; j++) {
        for (let i = 1; i <= N; i++) {
          u[IX(i,j)] -= 0.5 * N * (p[IX(i+1,j)] - p[IX(i-1,j)]);
          v[IX(i,j)] -= 0.5 * N * (p[IX(i, j+1)] - p[IX(i, j-1)]);
        }
      }
      setBnd(1, u);
      setBnd(2, v);
    }

    // ADD SOURCES (velocity or density)
    function addSource(x, s) {
      for (let i = 0; i < x.length; i++) {
        x[i] += physicsDt * s[i];
      }
    }

    // DRAW TEMPERATURE FIELD WITH ANTI-ALIASING
    function renderDensity() {
      const cellW = canvas.width / N;
      const cellH = canvas.height / N;
      
      // Use image data to avoid grid lines
      const imageData = ctx.createImageData(canvas.width, canvas.height);
      const data = imageData.data;
      
      for (let j = 1; j <= N; j++) {
        for (let i = 1; i <= N; i++) {
          // map dens âˆˆ [0,1] â†’ t âˆˆ [0,1]
          const T = dens[IX(i,j)];
          const t = Math.max(0, Math.min(1, T));
          
          // Calculate color using HSL to RGB conversion
          // hue from blue (240) to red (0)
          const hue = (1 - t) * 240;
          
          // Convert HSL to RGB
          const h = hue / 60;
          const s = 1;
          const l = 0.5;
          
          const c = (1 - Math.abs(2 * l - 1)) * s;
          const x = c * (1 - Math.abs(h % 2 - 1));
          const m = l - c/2;
          
          let r, g, b;
          
          if (h >= 0 && h < 1) { r = c; g = x; b = 0; }
          else if (h >= 1 && h < 2) { r = x; g = c; b = 0; }
          else if (h >= 2 && h < 3) { r = 0; g = c; b = x; }
          else if (h >= 3 && h < 4) { r = 0; g = x; b = c; }
          else if (h >= 4 && h < 5) { r = x; g = 0; b = c; }
          else { r = c; g = 0; b = x; }
          
          // Scale and apply base luminance
          r = Math.round((r + m) * 255);
          g = Math.round((g + m) * 255);
          b = Math.round((b + m) * 255);
          
          // Fill the corresponding rectangle in the image data
          const startX = Math.floor((i-1) * cellW);
          const startY = Math.floor(canvas.height - j * cellH);
          const endX = Math.floor(i * cellW);
          const endY = Math.floor(canvas.height - (j-1) * cellH);
          
          for (let y = startY; y < endY; y++) {
            for (let x = startX; x < endX; x++) {
              if (x >= 0 && x < canvas.width && y >= 0 && y < canvas.height) {
                const index = (y * canvas.width + x) * 4;
                data[index] = r;
                data[index + 1] = g;
                data[index + 2] = b;
                data[index + 3] = 255; // alpha
              }
            }
          }
        }
      }
      
      ctx.putImageData(imageData, 0, 0);
    }

    // ONE PHYSICS TIME-STEP
    function simulate() {
      // clear old sources
      u_prev.fill(0);
      v_prev.fill(0);
      dens_prev.fill(0);

      // 1) heating injection
      if (heating) {
        const cellW = canvas.width / N;
        const cellH = canvas.height / N;
        const ci = Math.floor(mX / cellW) + 1;
        const cj = N + 1 - Math.floor(mY / cellH);
        for (let di = -heatRadius; di <= heatRadius; di++) {
          for (let dj = -heatRadius; dj <= heatRadius; dj++) {
            const ii = ci + di, jj = cj + dj;
            if (ii>=1 && ii<=N && jj>=1 && jj<=N) {
              const d2 = di*di + dj*dj;
              if (d2 <= heatRadius*heatRadius) {
                const w = Math.exp(-d2/(2*heatRadius*heatRadius));
                const id = IX(ii,jj);
                dens_prev[id] += heatAmp * w;
              }
            }
          }
        }
      }

      // 2) continuous buoyancy (hot rises, cool sinks)
      prev_avg_density = avg_density;
      avg_density = 0;
      for (let j = 1; j <= N; j++) {
        for (let i = 1; i <= N; i++) {
          const id = IX(i,j);
          avg_density += dens[id]; // accumulate density for buoyancy
          const anomaly = dens[id] - prev_avg_density;
          // hotter than ambient â†’ upward (positive v)
          v_prev[id] += buoyancyCoeff * anomaly;
        }
      }
      avg_density /= N*N; // average density of the grid
      
      // 3) VELOCITY STEP
      addSource(u, u_prev);
      addSource(v, v_prev);

      // diffuse u,v
      u0.set(u);
      diffuse(1, u, u0, visc);
      v0.set(v);
      diffuse(2, v, v0, visc);

      // project
      project(u, v, u0, v0);

      // advect u,v
      u0.set(u);
      v0.set(v);
      advect(1, u, u0, u0, v0);
      advect(2, v, v0, u0, v0);

      // project again
      project(u, v, u0, v0);

      // 4) DENSITY STEP
      addSource(dens, dens_prev);

      dens0.set(dens);
      diffuse(0, dens, dens0, diff);

      dens0.set(dens);
      advect(0, dens, dens0, u, v);

      // 5) surface cooling (only top rows)
      for (let k = 0; k < 3; k++) {
        const j = N - k;                         
        const gradient = 1/(k+1);           
        for (let i = 1; i <= N; i++) {
            const rate = coolRate/100 * gradient;      
            const noise = 1 + (Math.random() - 0.5) * 0.2;  // Â±10%
            dens[IX(i, j)] *= (1 - rate * noise);
            dens[IX(i, j)] = Math.max(0, dens[IX(i, j)]); // clamp to [0,1]
        }
      }

      // ensure density boundaries after cooling
      setBnd(0, dens);
    }

    // UPDATE FPS COUNTER
    function updateFPS(timestamp) {
      frameCount++;
      
      // Update FPS every second
      if (timestamp - lastFpsUpdate >= 1000) {
        currentFps = Math.round(frameCount * 1000 / (timestamp - lastFpsUpdate));
        fpsDisplay.textContent = `FPS: ${currentFps}`;
        
        frameCount = 0;
        lastFpsUpdate = timestamp;
      }
    }

    // MAIN LOOP - NOW USING TIMESTAMP
    function step(timestamp) {
      if (!lastTimestamp) {
        lastTimestamp = timestamp;
        lastFpsUpdate = timestamp;
        requestAnimationFrame(step);
        return;
      }
      
      // Calculate delta time in seconds
      const deltaTime = (timestamp - lastTimestamp) / 1000;
      lastTimestamp = timestamp;
      
      // Limit delta time to avoid spiral of death on slow devices
      const cappedDeltaTime = Math.min(deltaTime, 0.1);
      
      // Add to accumulated time with user's time scale factor
      accumulatedTime += cappedDeltaTime * timeScale;
      
      // Fixed timestep physics updates
      const physicsTimestep = 1.0 / targetPhysicsRate;
      
      // While we have enough accumulated time, run physics updates
      while (accumulatedTime >= physicsTimestep) {
        simulate();
        accumulatedTime -= physicsTimestep;
      }
      
      // Render the simulation
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      renderDensity();
      
      // Update FPS counter
      updateFPS(timestamp);
      
      // Request next frame
      requestAnimationFrame(step);
    }

    // Handle keyboard events for FPS display toggle
    document.addEventListener('keydown', (e) => {
      if (e.key.toLowerCase() === 'f') {
        const fpsDisplay = document.getElementById('fps');
        if (fpsDisplay.style.display === 'block') {
          fpsDisplay.style.display = 'none';
        } else {
          fpsDisplay.style.display = 'block';
        }
      }
    });
    
    // Handle passive touch events properly
    function preventScroll(e) {
      if (e.target === canvas) {
        e.preventDefault();
      }
    }
    
    document.addEventListener('touchmove', preventScroll, { passive: false });
    document.addEventListener('touchstart', preventScroll, { passive: false });
    
    // Start the simulation with requestAnimationFrame
    requestAnimationFrame(step);
  </script>
</body>
</html>